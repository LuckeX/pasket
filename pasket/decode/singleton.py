import re
import logging

import lib.const as C
import lib.visit as v

from .. import util
from ..meta import methods, classes, class_lookup
from ..meta.template import Template
from ..meta.clazz import Clazz
from ..meta.method import Method
from ..meta.field import Field
from ..meta.statement import Statement, to_statements
from ..meta.expression import Expression

class Singleton(object):

  ## hole assignments for roles
  ## glblInit_role_????,StmtAssign,role_???? = n
  regex_role = r"((({})_\S+)_{}).* = (\d+)$".format('|'.join(C.sng_roles), C.SNG.AUX)

  @staticmethod
  def simple_role_of_interest(msg):
    return re.match(Singleton.regex_role, msg)

  # add a mapping from role variable to its value chosen by sketch
  def add_simple_role(self, msg):
    m = re.match(Singleton.regex_role, msg)
    v, n = m.group(1), m.group(4)
    self._role[v] = n

  # initializer
  def __init__(self, output_path):
    self._output = output_path
    self._demo = util.pure_base(output_path)

    self._cur_mtd = None
    self._role = {} # { v : n }

    # class roles
    self._sngs = []

    # method roles
    self._gttrs = []

    # interpret the synthesis result
    with open(self._output, 'r') as f:
      for line in f:
        line = line.strip()
        try:
          items = line.split(',')
          func, kind, msg = items[0], items[1], ','.join(items[2:])
          if Singleton.simple_role_of_interest(msg): self.add_simple_role(msg)
        except IndexError: # not a line generated by custom codegen
          pass # if "Total time" in line: logging.info(line)

  @property
  def demo(self):
    return self._demo

  @v.on("node")
  def visit(self, node):
    """
    This is the generic method to initialize the dynamic dispatcher
    """

  @v.when(Template)
  def visit(self, node):
    def find_role(lst, role):
      ids = []
      for v in self._role:
        if v.startswith(role): ids.append(int(self._role[v]))
      return [ lst[_id] for _id in ids ]

    # find and store class roles
    self._sngs = find_role(classes(), C.SNG.SNG)
    logging.debug("singleton(s): {}".format(self._sngs))

    # find and store method roles
    self._gttrs = find_role(methods(), C.SNG.GET)
    logging.debug("getter(s): {}".format(self._gttrs))

  @v.when(Clazz)
  def visit(self, node):
    if node in self._sngs:
      # make the constructor(s) *private*
      inits = node.inits
      if not inits: inits = [node.add_default_init()]
      for init in inits:
        if C.mod.PR not in init.mods: init.mods.append(C.mod.PR)
        # rip off *public* modifier, if exists
        try: init.mods.remove(C.mod.PB)
        except ValueError: pass

      # add a static field to hold the singleton instance
      cname = node.name
      fname = C.SNG.INS
      holder = Field(clazz=node, mods=[C.mod.PR, C.mod.ST], typ=cname, name=fname)
      logging.debug("adding field {0}.{1} of type {0}".format(cname, fname))
      node.add_flds([holder])

  @v.when(Field)
  def visit(self, node): pass

  @v.when(Method)
  def visit(self, node):
    self._cur_mtd = node

    if node in self._gttrs:
      cname = node.clazz.name
      mname = node.name
      fname = C.SNG.INS
      body = u"""
        if ({fname} == null) {{
          {fname} = new {cname}();
        }}
        return {fname};
      """.format(**locals())
      logging.debug("filling getter {}.{}".format(cname, mname))
      node.body = to_statements(node, body)

  @v.when(Statement)
  def visit(self, node):
    if node.kind == C.S.RETURN:
      call = unicode(node)
      ## Aux...getterInOne(...);
      if call.startswith(u"return " + C.SNG.AUX):
        return to_statements(self._cur_mtd, u"return null;")

    return [node]

  @v.when(Expression)
  def visit(self, node): return node

